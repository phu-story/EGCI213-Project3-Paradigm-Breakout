package self;

import java.awt.*;

class Ball
{
    private int x, y, cx, cy, speed, size;
    private final Color color;
    static final int MAX_SPEED = 7;
    
    public Ball(int x, int y, int cx, int cy, int speed, Color color, int size) {
        this.x = x;
        this.y = y;
        this.cx = cx;
        this.cy = cy;
        this.speed = speed;
        this.color = color;
        this.size = size;
    }
    
    public void paint(Graphics g)
    {
        g.setColor(color);
        
        g.fillOval(x, y, size, size);
    }

    public void moveBall()
    {
        x += cx;
        y += cy;
    }
    
    public void bounceOffEdge(int top, int bottom)
    {
        /**
        * @param top - the y value of the top of the screen
        * @param bottom - the y value of the bottom of the screen
        */

        if(y > bottom-size - 30)
        {
            reverseY();
        }
        else if(y < top + 5)
        {
            reverseY();
        }

        /*if(x < 0)
        {
            reverseX();
        }
        else if(x > 640-size - 10)   //code to cage the ball. but since getting off x bound
        {                            //will result in opp's getting more score, ts is no important no more
            reverseX();
        }
        */ 
    }
    
    public void reverseX()
    {
        cx *= -1;
    }

    public void reverseY()
    {
        cy *= -1;
    }

    public int getY()               { return y; }
    public int getX()               { return x; }
    public int getSize()            { return size; }
    public void setX(int x)         { this.x = x; }
    public void setY(int y)         { this.y = y; }
    public void setCx(int cx)       { this.cx = cx; }
    public void setCy(int cy)       { this.cy = cy; }
    public void setSpeed(int speed) { this.speed = speed; }
    
    public void increaseSpeed()
    {
        if(speed<MAX_SPEED)
        {
            speed++;

            cx = (cx/Math.abs(cx) * speed);
            cy = (cy/Math.abs(cy) * speed);
        }
    }

}package self;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;


class Main extends JFrame
{
    static JFrame f = new JFrame("Pong");
    private static final int DELAY = 33; //this is the frequency of how much a frame would be updated

    public static void main(String[] args)
    {
        f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        f.setSize(650, 495);
        PongGame game = new PongGame();
        f.add(game);
        
       
        f.setVisible(true);
        
        //timer works as a frame updater, everytime it runs, in this case, every 33 milisecs
        //game will call repaint
        Timer timer = new Timer(DELAY, new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {

                        game.gameLogic();
                        game.repaint();
                    }
                });

           
           timer.start();

    }
}package self;

import java.awt.*;

class Paddle
{
     private int height, x, y, speed;
    private Color color;

    //constant
    static final int PADDLE_WIDTH = 15;

    /**
     * A paddle is just a ping pong bat
     * @param x x cord of starting position of a paddle
     * @param y y cord of starting position of a paddle
     * @param height the paddle height
     * @param speed the amount the paddle may move per frame   CAN CHANGE LATER
     * @param color the paddle color
     */
    public Paddle(int x, int y, int height, int speed, Color color) {
        this.x = x;
        this.y = y;
        this.height = height;
        this.speed = speed;
        this.color = color;
    }

    public void paint(Graphics g)
    {
        g.setColor(color);
        g.fillRect(x, y, PADDLE_WIDTH, height);
    }
    
    /**
    * Move the paddle towards this y position every frame (centered)
    * @param moveToY - position the paddle is centered on
    */

    public void moveToward(int moveToY)
    {
        /**
        * Move the paddle towards this y position every frame (centered)
        * @param moveToY - position the paddle is centered on
        */

        //find the location of the center of the paddle
        //@param centerY is also a "relative" center of the paddle, based on current y
        int centerY = y + height/2;

        if(Math.abs(centerY - moveToY) > speed) //check whether the difference between moveTo
        {                                       //and point we want to go is not more than the distance
            if(centerY >  moveToY)              //paddle usually travels
            {
                y -= speed;
            }

            if(centerY < moveToY )
            {
                y += speed;
            }

        }
    }

    /**
    *
    * @param b the ball we're checking for a collision with
    * @return true if collision is detected
    */
    public boolean checkCollision(Ball b)
    {
        int rightX = x + PADDLE_WIDTH;
        int bottomY = y + height;

        if( ( b.getX() + b.getSize() ) > x && b.getX() < rightX ) //check if ball is between the paddle (x cord)
        {
            if( ( b.getY() + b.getSize() ) > y && b.getY() < bottomY) //check if ball is between the paddle (y cord)
            {
                return true;
            }
        }
        
        return false; //nah, they aint be hitting bro (insert emoji cry)

    }

    

}
package self;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;


class PongGame extends JPanel implements MouseMotionListener, KeyListener
{
    static final int WINDOW_WIDTH = 640, WINDOW_HEIGHT = 480;
    private Ball gameBall;
    private Paddle userPaddle, pcPaddle;
    private int userMouseY;

    //customizable attribute
    /*
     * little explanation here, cx cy and speed should be the same at first
     * cx and cy is how much a ball moves in one unit of time, or basically every one frame updated
     * which is about 33 miliseconds (check in main), the "speed" variable is only useful
     * in increaseSpeed() method, aside from that, it has no use, for now
     */
    
    private final int cx=3, cy=3, ballSpeed=3; //to make it harder, increase all THREE variables
    private final int userPaddleSpeed=3;
    private final int pcPaddleSpeed=3;

    private int userScore, pcScore, bounceCount;

    private Timer paddleKeyTimer;
    private boolean upKeyPressed=false, downKeyPressed=false;
    
    

    public PongGame()
    {
        gameBall = new Ball(300, 200 , cx ,cy , ballSpeed , Color.YELLOW, 10); //SPEED IS 3
        userPaddle = new Paddle(10, 200, 75, userPaddleSpeed, Color.BLUE); //SPEED CAN CHANGE HERE, COLOR AS WELL
        pcPaddle = new Paddle(610, 200, 75, pcPaddleSpeed, Color.RED);

        userMouseY = 0;
        
        userScore =0; pcScore =0;
        bounceCount=0;

        addMouseMotionListener(this);
        addKeyListener(this);
    }
    
    @Override
    public void paintComponent(Graphics g)
    {
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
        
        gameBall.paint(g);
        
        userPaddle.paint(g);
        pcPaddle.paint(g);

        g.setColor(Color.WHITE); //SCORE BOARD CAN ALSO BE CUSTOMIZED HERE
        String scoreBoard = "Score - user [ " + userScore + " ] PC [ " + pcScore + " ]"; 
        g.drawString(scoreBoard, 250, 20);
             
    }

    public void gameLogic()
    {
        gameBall.moveBall();
        gameBall.bounceOffEdge(0, WINDOW_HEIGHT);
        userPaddle.moveToward(userMouseY);
        pcPaddle.moveToward(gameBall.getY()); //EASIEST IMPLEMENTATION, PCPADDLE ALWAYS MOVES TOWARD THE BALL
                                              //We can make it harder though
        if(pcPaddle.checkCollision(gameBall) || userPaddle.checkCollision(gameBall))
        {
            gameBall.reverseX();
            bounceCount++;
        }

        if(bounceCount == 5)
        {
            bounceCount=0;
            gameBall.increaseSpeed();
        }

        outXBound(gameBall);

        paddleKeyTimer = new Timer(33, e-> {
            if(upKeyPressed && userMouseY > 0)
            {
                userMouseY-=userPaddleSpeed;
            }
            if(downKeyPressed && userMouseY < 640 )
            {
                userMouseY+=userPaddleSpeed;
            }
        });


    }

    @Override
    public void mouseDragged(MouseEvent e) {

    }

    @Override
    public void mouseMoved(MouseEvent e) {

        userMouseY = e.getY();

    }

    public void reset()
    {
        try
        {
            Thread.sleep(1000);
        }
        catch(Exception e)
        {   
            e.printStackTrace();
        }

        gameBall.setX(300);
        gameBall.setY(200);
        gameBall.setCx(3);
        gameBall.setCy(3);
        gameBall.setSpeed(3);
        bounceCount = 0;
    }

    public void outXBound(Ball gameBall)
    {
        if(gameBall.getX() < 0) //condition checking whether lose or not
        {
            pcScore++;
            reset();
        }
        else if(gameBall.getX() > WINDOW_WIDTH)
        {
            userScore++;
            reset();
        }
    }

     @Override
    public void keyPressed(KeyEvent e) {
        int keycode = e.getKeyCode();
        
        if(keycode == KeyEvent.VK_UP && !upKeyPressed)
        {
            upKeyPressed = true;
            paddleKeyTimer.start();
        }
        if(keycode == KeyEvent.VK_DOWN && !downKeyPressed)
        {
            downKeyPressed = true;
            paddleKeyTimer.start();
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
         int keyCode = e.getKeyCode();

        if (keyCode == KeyEvent.VK_UP) {
            upKeyPressed = false;  // Stop printing when UP key is released
        }

        if (keyCode == KeyEvent.VK_DOWN) {
            downKeyPressed = false;  // Stop printing when DOWN key is released
        }

        // Stop the timer when no keys are pressed
        if (!upKeyPressed && !downKeyPressed) {
            paddleKeyTimer.stop();
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
        // Optionally handle key typed events if needed
    }

    


}


